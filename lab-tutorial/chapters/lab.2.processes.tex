\chapter{Lab 2 - Processes}

% Processes, Threads (Intro), Process Creation and Context Switching

Congratulations on completing the first lab! Hopefully you have had a chance to play
around with the MOS kernel and have a better understanding of its structure.

In this lab, we will be looking at the process management system in MOS.

\section{Process Control Blocks}

You have learnt about this in the lecture: `a process is a program in execution', and a process
control block (PCB) is a data structure that contains information about a process.

Now, let's look at the PCB structure in MOS. In \texttt{kernel/include/mos/tasks/task\_types.h}.

The first field is a magic number, which is used to check if we are dealing with a valid PCB.
Then follows the process name and its PID, a list of opened files, a list of threads and a list
of mapped memory regions, which we will look more closely at later.

Each process has a parent, which is the process that created it, and this forms a tree-like
structure.

\begin{note}
    \item At the root of the tree is the \texttt{init} process, it's fun to think about
    it being its own parent.
\end{note}

\section{Thread Control Blocks}

You may have noticed that the PCB above is different from the one in the lecture: it doesn't
have a `process state' or its `stack/heap/text memory regions'. This is because MOS is using
thread as a basic unit of execution, and each thread has its own state.

The thread control block is defined in the same file as the PCB. You can see that it contains
a \texttt{tid} for a thread id, and a \texttt{state} field to indicate the state of the thread,
its owner process, two stacks for the kernel and user mode respectively.

There's also a \texttt{context} pointer, this will be used in context switching, we'll look at
that later.

\section{Process Creation}

A process has to be created from a `program' (a binary executable file) in order to be
executed. WLOG, creating a process involves the following steps:

\begin{enumerate}
    \item Load the program into the memory.
    \item Create a PCB and populate the fields.
          \begin{enumerate}
              \item Allocate and initialize the PCB.
              \item Allocate a user-mode page table.
              \item Parse the program and map corresponding memory regions into the page table.
              \item Allocate a heap for the process in the user-mode page table.
                    (part 2 in Figure \ref{fig:mos-process-memory-layout})
              \item Add the PCB to the process table.
          \end{enumerate}
    \item Create a main thread.
          \begin{enumerate}
              \item Allocate and initialize the TCB for the main thread.
              \item Allocate \textbf{both} the user-space and kernel-space stack space for the thread.
                    (part 2 in Figure \ref{fig:mos-process-memory-layout})
              \item Add the thread to the thread table.
              \item Set thread state to \texttt{CREATED}.
          \end{enumerate}
    \item (optionally) schedule to the new thread.
\end{enumerate}

The figure \ref{fig:mos-process-memory-layout} shows the memory layout of a process in MOS
after its creation.

\begin{figure}
    \definecolor{lightcyan}{rgb}{0.8,1,1}
    \definecolor{lightgreen}{rgb}{0.56,0.93,0.56}
    \definecolor{lightlightgreen}{rgb}{0.8,1,0.8}
    \definecolor{gray}{rgb}{0.7,0.7,0.7}
    \definecolor{lightred}{rgb}{1,0.7,0.71}

    % \memsection{end address}{start address}{height in lines}{text in box}{color}
    \newcommand{\memsection}[6][lrtb]{%
        \bytefieldsetup{bitheight=#4\baselineskip}%
        \bitbox[]{10}{
            \texttt{#2} \\ % end addressd
            \vspace{#4\baselineskip}
            \vspace{-2\baselineskip}
            \vspace{-#4pt}
            \texttt{#3} % start address
        }
        \bitbox[#1]{16}[bgcolor=#5]{\small #6}
    }

    \newcommand{\memgap}[2][lrtb]{
        \bytefieldsetup{bitheight=#2\baselineskip}
        \bitbox[#1]{16}[bgcolor=gray]{\small Gap}
    }

    Color Description:
    \colorbox{gray}{\textbf{Unavailable}}
    \colorbox{lightred}{\textbf{Kernel Only}}
    \colorbox{lightgreen}{\textbf{User Read-Only}}
    \colorbox{cyan}{\textbf{User Read-Write}}

    \begin{center}
        \begin{bytefield}{24}
            \memsection{0xffffffff}{0xC0000000}{6}{lightred}{Kernel}\\
            \memgap{6}\\
            \begin{leftwordgroup}{2. Address determined\\ by the MOS Kernel}
                \begin{rightwordgroup}{4. Per-thread\\Memory Regions}
                    \memsection{\dots}{}{2}{lightred}{\scriptsize{Kernel-Mode Thread Stacks \dots}}\\
                    \memsection{}{}{2}{cyan}{\scriptsize{User-Mode Thread Stacks \dots}}
                \end{rightwordgroup}\\
                \begin{rightwordgroup}{4. \textbf{Main} Thread\\Memory Regions}
                    \memsection{}{}{2}{lightred}{\scriptsize{Kernel-Mode \textbf{Main} Thread Stack}}\\
                    \memsection{0x60020000}{\dots}{2}{cyan}{\scriptsize{User-Mode \textbf{Main} Thread Stack}}
                \end{rightwordgroup}\\
                \memgap{2}\\
                \begin{rightwordgroup}{3. Per-process\\Memory Regions}
                    \memsection[ltr]{}{}{5}{lightcyan}{\textit{Future} Heap \textit{Area}}\\
                    \memsection[lbr]{}{0x40000000}{3}{cyan}{\texttt{\large{$\uparrow$}} \\ Heap}
                \end{rightwordgroup}
            \end{leftwordgroup}\\
            \memgap{4}\\
            \begin{leftwordgroup}{1. Address determined\\ by the Program Header}
                \memsection{\dots}{}{3}{cyan}{\texttt{.bss} Section}\\
                \memsection{}{}{3}{cyan}{\texttt{.data} Section}\\
                \memsection{}{}{2}{lightgreen}{\texttt{.rodata} Section}\\
                \memsection{}{0x08048000}{2}{lightgreen}{\texttt{.text} Section}
            \end{leftwordgroup}\\
            \memsection{}{0x00000000}{5}{gray}{Unavailable}\\
        \end{bytefield}
    \end{center}
    \caption{The memory layout of a process in MOS (Not to scale)}
    \label{fig:mos-process-memory-layout}
\end{figure}

\textbf{\textit{TODO: Add exercises}}

\section{The famous \texttt{fork()} system call}

You may have known that the \texttt{fork()} system call is used to create a new process, which seems
to be the same as what we have just discussed. However, think about the following question:

\begin{quote}
    What if we want to create a new process that is exactly the same as the current process, instead
    of creating a new process from a program?
\end{quote}

\dots
