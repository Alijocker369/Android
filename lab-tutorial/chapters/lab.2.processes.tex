\chapter{Lab 2 - Processes}

% Processes, Threads (Intro), Process Creation and Context Switching

Firstly, congratulations on completing the first lab! Hopefully you have had a chance to play
around with the MOS kernel and have a better understanding of its structure.

In this lab, we will be looking at the process management system in MOS.

\section{Process Control Blocks}

You have learnt about this in the lecture: `a process is a program in execution', and a process
control block (PCB) is a data structure that contains information about a process.

Now, let's look at the PCB structure in MOS. In \texttt{kernel/include/mos/tasks/task\_types.h}.

The first field is a magic number, which is used to check if we are dealing with a valid PCB.
Then follows the process name and its PID, a list of opened files, a list of threads and a list
of mapped memory regions, which we will look more closely at later.

Each process has a parent, which is the process that created it, and this forms a tree-like
structure.

\begin{note}
    \item At the root of the tree is the \texttt{init} process, it's fun to think about
    it being its own parent.
\end{note}

\section{Thread Control Blocks}

You may have noticed that the PCB above is different from the one in the lecture: it doesn't
have a `process state' or its `stack/heap/text memory regions'. This is because MOS is using
thread as a basic unit of execution, and each thread has its own state.

The thread control block is defined in the same file as the PCB. You can see that it contains
a \texttt{tid} for a thread id, and a \texttt{state} field to indicate the state of the thread,
its owner process, two stacks for the kernel and user mode respectively.

There's also a \texttt{context} pointer, this will be used in context switching, we'll look at
that later.

\section{Process Creation}

A process has to be created from a `program' (a binary executable file) in order to be
executed. WLOG, creating a process involves the following steps:

\begin{enumerate}
    \item Load the program into memory.
          \begin{enumerate}
              \item Allocate memory for the program.
              \item Read the program from the disk.
              \item Parse the program and map corresponding memory regions.
          \end{enumerate}
    \item Create a PCB for the process.
          \begin{enumerate}
              \item Allocate memory for the PCB.
              \item Initialize the PCB with the information of the program.
              \item Add the PCB to the process table.
          \end{enumerate}
    \item Create a thread for the process.
          \begin{enumerate}
              \item Allocate the main thread's TCB.
              \item Initialize TCB.
              \item Create the main thread's stack, in MOS, both the userspace and the kernel stack.
                    TODO CHANGE THIS, IT'S NOT ONLY ALLOCATING THE STACK, BUT ALSO THE HEAP
              \item Add the thread to the thread table.
              \item Mark the thread as \texttt{CREATED}.
          \end{enumerate}
\end{enumerate}

As you can see, the main steps are just to fill in the PCB and TCB with correct information loaded
from the program, and then add them to the corresponding tables.

TODO: Follow the code and explain the details?

TODO: Add a diagram?

TODO: Add some exercises?

\section{The famous \texttt{fork()} system call}

You may have known that the \texttt{fork()} system call is used to create a new process, which seems
to be the same as what we have just discussed. However, think about the following question:

\begin{quote}
    What if we want to create a new process that is exactly the same as the current process, instead
    of creating a new process from a program?
\end{quote}

\dots
